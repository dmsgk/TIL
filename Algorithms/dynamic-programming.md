# Dynamic Programming

## Dynamic Programming이란?

- 문제를 각각의 작은 문제로 나누어 해결한 결과를 저장해뒀다가 나중에 큰 문제의 결과와 합하여 풀이하는 알고리즘

- 최적 부분 구조(문제의 최적 해결방법이 부분 문제에 대한 최적 해결방법으로 구성되는 경우)의 문제를 해결할 수 있다.

- 최적 부분 구조를 푼다는 점에서 그리디 알고리즘과 유사하나, 다이나믹 프로그래밍은 **중복된 하위 문제들**의 결과를 저장해뒀다가 풀어나간다는 점에서 차이가 있다. 

  ###### 다이나믹 프로그래밍, 그리디 알고리즘, 분할 정복 알고리즘 비교

| 알고리즘            | 풀이 가능한 문제들의 특징              | 풀이 가능한 문제 및 알고리즘 |
| ------------------- | :------------------------------------- | ---------------------------- |
| 다이나믹 프로그래밍 | - 최적 부분 구조(Optimal Substructure)<br />- 중복된 하위 문제들(Overlapping Subproblems) | * 0-1 배낭 문제<br />* 피보나치 수열<br />* 다익스트라 알고리즘 |
| 그리디 알고리즘     | - 최적 부분 구조<br />- 탐욕 선택 속성       | * 분할 가능 배낭 문제<br />* 다익스트라 알고리즘 |
| 분할 정복           | - 최적 부분 구조                       | * 병합 정렬<br />* 퀵 정렬      |



## 다이나믹 프로그래밍 패러다임

### 1. 최적 부분 구조

- 문제의 해결 방법이 부분 문제에 대한 최적 해결방법으로 구성된다. 

### 2. 중복된 하위 문제들

- 작은 문제에서 반복이 일어난다.



## 다이나믹 프로그래밍 방법론

> 상향식은 해결이 용이하지만, 가독성이 저하된다. 
>
> 하향식은 가독성이 좋지만, 코드 작성이 어렵다. 



### 상향식(= Tabulation)

- 작은 하위 문제부터 살펴본 다음, 작은 문제의 정답을 이용해 큰 문제의 정답 풀어나가는 방식

- 협의의 DP

- 예시 - 피보나치 수열 

  ```python
  def fib(n):
    dp[0] = 0
    dp[1] = 1
    
    for i in range(2, n+1):
      dp[i] = dp[i-1] + dp[i-2]
   	return dp[n]
  ```

### 하향식(= Memoization)

- 하위 문제에 대한 정답을 계산했는지 확인해가며 문제를 자연스러운 방식으로 풀어 나간다. 

- 이미 푼 값은 다시 계산하지 않음으로써 시간을 절약한다는 점에서 일반적인 재귀 풀이와 차이가 있다.

- 예시 - 피보나치 수열

  ```python
  def fib(n):
    if n <= 1:
      return n
    
    if dp[n]:
      return dp[n]
    dp[n] = fib(n-1) + fib(n-2)
    return dp[n]
  
  # 하위 문제에 대한 정답을 계산했는지 확인해가며 재귀로 풀어나감. 
  ```



## DP문제 접근방법 

- 작은 단위의 문제를 해결해본다. 
- 자신의 순서에 가능한 경우의 수를 모두 고려한다.

- 경우의 수에 따라 i번째 값이 가질 수 있는 경우 중 최적의 수를 찾는 과정을 계속한다.



### References

- 박상길, 2020, 파이썬 알고리즘 인터뷰, 책만.
- https://github.com/gyoogle/tech-interview-for-developer/blob/master/Algorithm/%EB%8F%99%EC%A0%81%20%EA%B3%84%ED%9A%8D%EB%B2%95%20(Dynamic%20Programming).md



