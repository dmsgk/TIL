# Dynamic Programming

## Dynamic Programming이란?

- 문제를 각각의 작은 문제로 나누어 해결한 결과를 저장해뒀다가 나중에 큰 문제의 결과와 합하여 풀이하는 알고리즘

- 최적 부분 구조(문제의 최적 해결방법이 부분 문제에 대한 최적 해결방법으로 구성되는 경우)의 문제를 해결할 수 있다.

- 최적 부분 구조를 푼다는 점에서 그리디 알고리즘과 유사하나, 다이나믹 프로그래밍은 **중복된 하위 문제들**의 결과를 저장해뒀다가 풀어나간다는 점에서 차이가 있다. 

  ###### 다이나믹 프로그래밍, 그리디 알고리즘, 분할 정복 알고리즘 비교

| 알고리즘            | 풀이 가능한 문제들의 특징              | 풀이 가능한 문제 및 알고리즘 |
| ------------------- | :------------------------------------- | ---------------------------- |
| 다이나믹 프로그래밍 | - 최적 부분 구조(Optimal Substructure)<br />- 중복된 하위 문제들(Overlapping Subproblems) | * 0-1 배낭 문제<br />* 피보나치 수열<br />* 다익스트라 알고리즘 |
| 그리디 알고리즘     | - 최적 부분 구조<br />- 탐욕 선택 속성       | * 분할 가능 배낭 문제<br />* 다익스트라 알고리즘 |
| 분할 정복           | - 최적 부분 구조                       | * 병합 정렬<br />* 퀵 정렬      |



## 다이나믹 프로그래밍 패러다임

### 1. 최적 부분 구조

### 2. 중복된 하위 문제들



## 다이나믹 프로그래밍 방법론

### 상향식(= Tabulation)

- 작은 하위 문제부터 살펴본 다음, 작은 문제의 정답을 이용해 큰 문제의 정답 풀어나가는 방식

- 협의의 DP

- 예시 - 피보나치 수열 

  ```python
  def fib(n):
    dp[0] = 0
    dp[1] = 1
    
    for i in range(2, n+1):
      dp[i] = dp[i-1] + dp[i-2]
   	return dp[n]
  ```

### 하향식(= Memoization)

- 하위 문제에 대한 정답을 계산했는지 확인해가며 문제를 자연스러운 방식으로 풀어 나간다. 

- 예시 - 피보나치 수열

  ```python
  def fib(n):
    if n <= 1:
      return n
    
    if dp[n]:
      return dp[n]
    dp[n] = fib(n-1) + fib(n-2)
    return dp[n]
  
  # 하위 문제에 대한 정답을 계산했는지 확인해가며 재귀로 풀어나감. 기존 재귀풀이와 거의 동일하면서도 이미 풀어봤는지 확인하여 재활용하는 효율적인 방식이다.
  ```





### References

- 박상길, 2020, 파이썬 알고리즘 인터뷰, 책만.



