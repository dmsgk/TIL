# 시간복잡도(Time Complexity)

## 0. 문제풀이 할 때 예상하는 시간복잡도

| 데이터 크기 제한 | 예상되는 시간 복잡도  |
| ---------------- | --------------------- |
| n <= 1,000,000   | O(n) or O(n * log(n)) |
| n <= 10,000      | O(n**2)               |
| n <= 500         | O(n**3)               |

시간 제한 1~10초내에 데이터 제한 N에 대해 기본연산을 하기 위해 예상되는 시간 복잡도.



## 1. 시간복잡도란?

- 컴퓨터 프로그램의 입력값과 연산 수행 시간의 상관관계를 나타내는 척도이다. 

## 1.1. Big O 표기법
[![img](https://feel5ny.github.io/images/post_img/48/02.png)](https://feel5ny.github.io/images/post_img/48/02.png)

위 예와 같이 T(n)으로 표현한 함수의 `최고차항의 차수`가 빅오가 된다.
빅오의 순서는 아래와 같고 커질수록 좋지 않다.
보통 O(n^2)이상의 복잡도를 가지는 알고리즘은 좋지 않다.

 ![img](https://feel5ny.github.io/images/post_img/48/03.png)



|  시간복잡도   |                         설명                          |
| :-----------: | :---------------------------------------------------: |
|     O(1)      | 상수 형태. n의 값에 상관없이 일정한 양의 계산만 한다. |
|    O(logn)    |                       로그 형태                       |
|     O(n)      |                         선형                          |
|   O(nlogn)    |                     선형로그 형태                     |
| O(n2),O(n3),⋯ |                       다차 형태                       |
|     O(2n)     |                       지수 형태                       |
|     O(n!)     |                     팩토리얼 형태                     |

맨 위에서부터 시간 복잡도가 낮고 빠르고, 아래로 갈 수록 시간 복잡도가 높고 느려진다. 제한된 시간 안에 올바르게 output을 출력하려면 시간 복잡도를 낮춰야 할 것임을 알 수 있다. n의 값이 작을 때는 알고리즘 사이에 큰 차이가 없고, 심지어 시간 복잡도가 복잡한 알고리즘이 시간 복잡도가 낮은 알고리즘보다 부분적으로 빠른 경우도 있지만, n이 값이 커지면 커질수록 시간 복잡도가 복잡한 알고리즘은 수행 시간이 급격하게 길어진다. 



### 1.2. 연산 횟수 카운팅 

1. 최선의 경우 Best Case
2. 최악의 경우 Worst Case
3. 평균적인 경우 Average Case

평균적인 경우가 가장 이상적으로 보이겠지만 알고리즘이 복잡해 질수록 평균적인 경우는 구하기가 매우 어려워 진다. 그러므로 **최악의 경우**로 알고리즘의 성능을 파악한다.



## 2. 시간복잡도 계산하기

- 상수항은 무시하라

  ex) O(2N)이라고 표시되어야 하는 알고리즘은 O(N)으로 표기한다.

- 지배적이지 않은 항은 무시하라

  ex)

  - O(N^2 + N) 은 O(N^2)가 된다.
  - O(N+logN)은 O(N)이 된다.
  - O(5*(2^N)+1000* (N^100)) 은 O(2^N)이 된다.

- 여러 부분으로 이루어진 알고리즘: 덧셈 vs 곱셈

  - 만약 알고리즘이 A일을 **모두 끝마친 후** B일을 수행하는 형태라면 A와 B의 수행시간을 **더해야** 한다.
  - 만약 알고리즘이 **A일을 할 때마다 B일을 수행**하는 형태라면 A와 B의 수행시간을 **곱해야** 한다.

```python
# 시간복잡도 O(A + B)인 경우

for i in liA:
	print(i)
  
for j in liB:
	print(j)  
  
```

```python
# 시간복잡도 O(A * B)인 경우

for i in liA:
	for j in liB:
		print(i, j)
  
```



## 3. Asymptotic Complexity

입력의 크기가 충분히 클 때의 `시간복잡도`와 `공간복잡도`를 분석하는 것.

프로그램 성능이 Asymptotic(점진적인) Complexity

- 프로그램의 입력 크기 등 성능을 결정하는 주요 특성 값이 매우 클 때의 프로그램의 성능.
- 프로그램의 실행 속도가 어떤 경향을 가지는지를 평가한다고 생각하면 된다.
- ex. 입력의 크기가 n이고 n이 매우 큰 경우
- 프로그램 성능 평가의 매우 중요한 기준.

### 3-1. 점근적 분석의 필요성

- 어떠한 문제 해결을 위한 알고리즘의 성능분석을 할 때, 주어지는 데이터의 형태나 실험을 수행하는 환경, 또는 실험에 사용한 시스템의 성능등 다양한 요소에 의해 공평한 결과가 나오기 힘들고 비교 결과가 항상 일정하지 않을 수 있다.

- 이를 효과적으로 해결하는 방법이 점근적 분석법이다. 점근적 분석법은 `각 알고리즘이 주어진 데이터의 크기를 기준으로 수행시간 혹은 사용공간이 얼마나 되는지를 객관적으로 비교할 수 있는 기준을 제시해 준다.`
- O(빅오), Ω(오메가), Θ(세타)등이 있다. 일반적으로 빅오와 세타표기가 많이 사용된다.

### 3-2. Big-O Notation

- 점근적 상한선(Asymptotic upper bound)
- 주어진 알고리즘이 아무리 나빠도 비교하는 함수와 같거나 좋다.
- 정의 : O(g(n)) = {f(n) : there exist positive constants c and n0 such that 0≤f(n)≤cg(n) for all n≥n0}[![img](https://feel5ny.github.io/images/post_img/48/o_notation.png)](https://feel5ny.github.io/images/post_img/48/o_notation.png)
- n0를 기준으로 n0보다 오른쪽에 있는 모든 n 값에 대해 함수 f(n)은 함수 cg(n)보다 작거나 같다는 의미이다. 그래프가 아래에 있을 수록 수행시간이 짧은 것이므로 성능이 좋은 것이다.



## **4. Amortized Analysis**(분할 상환)

- 각각의 연산마다 최악의 경우를 따져본다는 것은 굉장히 힘든 일이기 때문에, 이를 쉽게 해결하기 위해 분할상환분석이라는 방법론이 나오게 되었다. 
- 최악의 경우는 가끔 발생하지만 한 번 발생하면 그 후로 꽤 오랫동안 나타나지 않으므로 "최악의 경우에 대해 최악의 경우가 발생하도록 연속된 연산을 수행하고, 그때의 한번의 연산에 대한 평균수행시간을 분석하는것"









### References

- 게일 라크만 맥도웰,  2017, 코딩인터뷰 완전분석,  인사이트(insight).
- https://zeddios.tistory.com/60 [ZeddiOS]
- https://ko.wikipedia.org/wiki/%EB%B6%84%ED%95%A0%EC%83%81%ED%99%98%EB%B6%84%EC%84%9D
- https://feel5ny.github.io/2017/12/09/CS_01/
- 출처: https://allo-ew.tistory.com/69 

